import { AlgorithmPage } from '@/components/AlgorithmPage';
import { ShellSortVisualizer } from '@/components/algorithms';

export const ShellSort = () => {
  return (
    <AlgorithmPage
      title="Shell Sort"
      overview={{
        description:
          'Shell Sort, also known as Shell\'s method or diminishing increment sort, is an optimization of Insertion Sort that allows elements to move long distances quickly. It works by comparing elements that are far apart (defined by a gap sequence), then progressively reducing the gap until it becomes 1, at which point the algorithm becomes a standard insertion sort. This implementation uses Knuth\'s sequence (1, 4, 13, 40, 121, ...) generated by the formula gap = gap * 3 + 1, which provides O(n^(3/2)) performance. Named after its inventor Donald Shell (1959), it was one of the first algorithms to break the O(n²) barrier.',
        advantages: [
          'Significantly faster than simple O(n²) algorithms for medium-sized arrays',
          'In-place sorting algorithm requiring only O(1) extra space',
          'Adaptive - performs better on partially sorted data',
          'Simple to implement and understand',
          'No recursive calls, making it efficient in terms of stack space',
          'Performance depends on gap sequence - can be tuned for specific data',
        ],
      }}
      visualizer={<ShellSortVisualizer />}
      complexityAnalysis={[
        {
          case: 'Best Case',
          complexity: 'O(n log n)',
          description:
            'With optimal gap sequences, Shell Sort can achieve O(n log n) on already sorted or nearly sorted data.',
        },
        {
          case: 'Average Case',
          complexity: 'O(n^(3/2)) to O(n^(4/3))',
          description:
            'Depends on the gap sequence used. The simple sequence (n/2, n/4, ..., 1) gives O(n²), while better sequences like Knuth\'s (3^k-1)/2 give O(n^(3/2)).',
        },
        {
          case: 'Worst Case',
          complexity: 'O(n²) to O(n log² n)',
          description:
            'With the simple gap sequence, worst case is O(n²). With optimal sequences like Sedgewick\'s, worst case can be O(n log² n).',
        },
        {
          case: 'Space Complexity',
          complexity: 'O(1)',
          description:
            'Shell Sort is an in-place algorithm requiring only a constant amount of additional space.',
        },
      ]}
      howItWorks={[
        {
          number: 1,
          title: 'Generate Knuth sequence:',
          description:
            'Generate gap sequence using Knuth\'s formula: 1, 4, 13, 40, 121, ... where each gap = previous_gap * 3 + 1. Stop when gap exceeds array length.',
        },
        {
          number: 2,
          title: 'Compare distant elements:',
          description:
            'Compare elements that are "gap" positions apart. This allows elements to jump over multiple positions quickly, unlike insertion sort which only moves elements one position at a time.',
        },
        {
          number: 3,
          title: 'Perform gapped insertion sort:',
          description:
            'For each gap value, perform an insertion sort on sub-arrays formed by elements that are gap positions apart. This partially sorts the array.',
        },
        {
          number: 4,
          title: 'Move to next smaller gap:',
          description:
            'After completing a pass with the current gap, move to the next smaller gap in the sequence (working backwards through the Knuth sequence). Continue sorting with the smaller gap.',
        },
        {
          number: 5,
          title: 'Final pass with gap=1:',
          description:
            'When the gap becomes 1, the algorithm performs a regular insertion sort. However, because the array is already partially sorted from previous passes, this final pass is very efficient.',
        },
        {
          number: 6,
          title: 'Array is sorted:',
          description:
            'After the gap=1 pass completes, the array is fully sorted. The earlier large-gap passes made the final insertion sort much faster.',
        },
      ]}
    />
  );
};
